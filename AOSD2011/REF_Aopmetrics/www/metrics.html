<html>
<head>
  <link rel="stylesheet" type="text/css" href="tigris.css"  />
  <title>AOP Metrics</title>
</head>
<body>

<h1>Metrics</h1>

<div class="h2"><h2>Table of contents</h2>

<ul>
 <li><a href="#simple">Simple metrics</a>
  <ul>
    <li><a href="#locc">Lines of Class Code (LOCC)</a></li>
  </ul>
 </li>
 <li><a href="#aopck">CK metrics suite for AOP</a>
  <ul>
   <li><a href="#wom">Weighted Operations in Module (WOM)</a></li>
   <li><a href="#dit">Depth of Inheritance Tree (DIT)</a></li>
   <li><a href="#noc">Number Of Children (NOC)</a></li>
   <li><a href="#cda">Crosscutting Degree of an Aspect (CDA)</a></li>
   <li><a href="#cim">Coupling on Intercepted Modules (CIM)</a></li>
   <li><a href="#cae">Coupling on Advice Execution (CAE)</a></li>
   <li><a href="#cmc">Coupling on Method Call (CMC)</a></li>
   <li><a href="#cfa">Coupling on Field Access (CFA)</a></li>
   <li><a href="#cfa">Coupling between Modules (CBM)</a></li>
   <li><a href="#rfm">Respone For a Module (RFM)</a></li>
   <li><a href="#lco">Lack of Cohesion in Operations (LCO)</a></li>
  </ul>
 </li>
 <li><a href="#pkg">Package dependecies</a>
  <ul>
   <li><a href="#not">Number of Types (NOT)</a></li>
   <li><a href="#a">Abstractness (A)</a></li>
   <li><a href="#ca">Afferent Couplings (Ca)</a></li>
   <li><a href="#ce">Efferent Couplings (Ce)</a></li>
   <li><a href="#mce">Modified Efferent Couplings (Ce)</a></li>
   <li><a href="#i">Instability (I)</a></li>
  </ul> 
 </li>
 <li><a href="#refs">References</a></li>
</ul>
</div>


<div class="h2"><h2><a name="simple">Simple metrics</a></h2>
<h3><a name="locc">Lines of Class Code (LOCC)</a></h3>

<p>LOCC counts number of <i>perfect</i> lines of class code.  It processes the internal string
representation of AJDT/JDT compiler, so the result is independent from original code styling etc.
</p>

<p><b>Implementation notes</b>:</p>
<ul>
 <li>every statement is in a single line,</li>
 <li>class, aspect, method and advice headers are counted as a one line,</li>
 <li>imports, comments, javadocs and empty newlines are not counted,</li>
 <li>newline is not created for a opening curly braces,</li>
 <li>newline is created for a closing curly braces,</li>
 <li>string constants are counted as a single line (even when it contains new lines).</li>
</ul>
</div>



<div class="h2"><h2><a name="aopck">CK metrics suite for AOP</a></h2>

<p>Metrics implemented by <b>aopmetrics</b> project can be applied to classes and
aspects. Therefore (like in <a href="#ceccato">[1]</a>) <i>module</i> will be
used as a common term for classes and aspects. Similarly, methods, advices
and introductions will be indicated by the <i>operation</i> term.</p>



<h3><a name="wom">Weighted Operations in Module (WOM)</a></h3>

<p>WOM counts number of operations in a given module <a href="#ceccato">[1]</a>.
 It's an equivalent of the WMC metric from CK metrics suite.</p>

<p>Similarly to the related OO metric, WOM captures the internal complexity of
 a module in terms of the number of implemented functions. 
 A more refined version of this metric can be obtained by giving different
 weights to operations with different internal complexity <a href="#ceccato">[1]</a>.
</p>

<p><b>View points:</b> <a href="#ck">[2]</a></p>
<ul>
 <li>The number of operations and the complexity of operations involved is a predictor 
  of how much time and effort is required to develop and maintain the module.</li>
 <li>The larger the number of operations in a module the greater the potential impact
   on children, since children will inherit all the operations defined in the module.</li> 
 <li>Modules with large numbers of operations are likely to be more application specific,
   limiting the possibility of reuse.</li> 
</ul>

<p><b>Implementation notes:</b></p>
<ul>
 <li>constructors and methods are counted as a member of a class or an aspect,</li>
 <li>advices and introductions of methods or constructors are counted as a member of an aspect.</li>
</ul>





<h3><a name="dit">Depth of Inheritance Tree (DIT)</a></h3>

<p>DIT is a length of the longest path from a given module to the class/aspect hierarchy root
 <a href="#ceccato">[1]</a>.</p>

<p>Similarly to the related OO metric, DIT measures the scope of the properties.
 The deeper a class/aspect is in the hierarchy, the greater the number of operations
 it might inherit, thus making it more complex to understand and change. Since aspects
 can alter the inheritance relationship by means of static crosscutting, such effects
 of aspectization must be taken into account when computing this metric <a href="#ceccato">[1]</a>.
</p>

<p><b>View points:</b> <a href="#ck">[2]</a></p>
<ul>
 <li>The deeper a module is in the hierarchy, the greater the number of operations it is
   likely to inherit, making it more complex to predict its behavior.</li>
 <li>Deeper trees constitute greater design complexity, since more operations and modules
  are involved.</li> 
 <li>The deeper a particular module is in the hierarchy, the greater the potential reuse
   of inherited operations.</li>
</ul>
  
<p><b>Implementation notes:</b></p>
<ul>
  <li>Object class is not counted.</li>
  <li>Modification of module's hierarchy using inter-type declarations are being considered.</li>
  <li>DIT for interfaces is always zero.</li>
</ul>



<h3><a name="noc">Number Of Children (NOC)</a></h3>

<p>NOC is a number of immediate subclasses or sub-aspects of a given module
 <a href="#ceccato">[1]</a>.</p>

<p>Similarly to DIT, NOC measures the scope of the properties, but
 in the reverse direction with respect to DIT. The number of children
 of a module indicates the proportion of modules potentially dependent
 on properties inherited from the given one <a href="#ceccato">[1]</a>.
</p>

<p><b>View points:</b> <a href="#ck">[2]</a></p>
<ul>
 <li>Greater the number of children, greater the reuse, since inheritance is a form of reuse.</li>
 <li>Greater the number of children, the greater the likelihood of improper abstraction of
   the parent module. If a module has a large number of children, it may be a case of misuse 
   of sub-classing.</li>
 <li>The number of children gives an idea of the potential influence a module has on the design.
   If a module has a large number of children, it may require more testing of the operations in
     that module.</li>
</ul>

<p><b>Implementation notes:</b></p>
<ul>
  <li>Modification of module's hierarchy using inter-type declarations are being considered.</li>
  <li>NOC for interfaces is always zero.</li>
</ul>



<h3><a name="cda">Crosscutting Degree of an Aspect (CDA)</a></h3>

<p>CDA is a number of modules affected by the pointcuts and by the introductions
 in a given aspect <a href="#ceccato">[1]</a>.</p>
 
<p>This is a brand new metric, specific to AOP software, that must be 
 introduced as a completion of the CIM metric. While CIM considers only 
 explicitly named modules, CDA measures all modules possibly affected by
 an aspect. This gives an idea of the overall impact an aspect has on
 the other modules. Moreover, the difference between CDA and CIM gives
 the number of modules that are affected by an aspect without being 
 referenced explicitly by the aspect, which might indicate the degree
 of generality of an aspect, in terms of its independence from specific
 classes/aspects. High values of CDA and low values of CIM are usually
 desirable <a href="#ceccato">[1]</a>.
</p>
 

<h3><a name="cim">Coupling on Intercepted Modules (CIM)</a></h3>
 
<p>CIM is a number of modules or interfaces explicitly named in the pointcuts
belonging to a given aspect. </p>

<p>This metric is the dual of CAE, being focused on the aspect that intercepts
 the operations of another module. However, CIM takes into account only those modules
  and interfaces an aspect is aware of - those that are explicitly mentioned
  in the pointcuts. Sub-modules, modules implementing named interfaces or modules
  referenced through wildcards are not counted in this metric, while they are in the
  metric CDA (see below), the rationale being that CIM (differently from CDA) captures
  the direct knowledge an aspect has of the rest of the system. High values of CIM indicate
  high coupling of the aspect with the given application and low generality/reusability
  <a href="#ceccato">[1]</a>.
</p>

<p><b>Implementation notes:</b></p>
<ul>
  <li>NOT IMPLEMENTED YET!</li>
</ul>



<h3><a name="cae">Coupling on Advice Execution (CAE)</a></h3>

<p>CAE is a number of aspects containing advices possibly triggered by the execution
  of operations in a given module <a href="#ceccato">[1]</a>.</p>

<p>If the behavior of an operation can be altered by an aspect  advice, due to 
  a pointcut intercepting it, there is an (implicit) dependence of the operation from
  the advice. Thus, the given module is coupled with the aspect containing the
  advice and a change of the latter might impact the former. Such kind of coupling is
  absent in OO systems <a href="#ceccato">[1]</a>.
</p>



<h3><a name="cmc">Coupling on Method Call (CMC)</a></h3>

<p>CMC is a number of modules or interfaces declaring methods that are possibly called
 by a given module <a href="#ceccato">[1]</a>.</p>

<p>This metric descends from the OO metric CBO (Coupling Between Objects), which
  was split into two (CMC and CFA) to distinguish coupling on operations from coupling
  on attributes. Aspect introductions must be taken into account when the possibly invoked
  methods are determined. Usage of a high number of methods from many
  different modules indicates that the function of the given module cannot be
  easily isolated from the others. High coupling is associated with a high
  dependence from the functions in other modules <a href="#ceccato">[1]</a>.
</p>

<p><b>Implementation notes:</b></p>
<ul>
 <li>constructor calls are counted as a method call,</li>
 <li>calls from introduced methods are counted as a call from aspect,</li>
 <li>introduced method calls are counted as a aspect's member calls.</li>
</ul>



<h3><a name="cfa">Coupling on Field Access (CFA)</a></h3>

<p>CFA is a number of modules or interfaces declaring fields that are accessed
  by a given module <a href="#ceccato">[1]</a>. </p>
  
<p>Similarly to CMC, CFA measures the dependences of a given module on other modules,
   but in terms of accessed fields, instead of methods. In OO systems this metric is usually
   close to zero, but in AOP, aspects might access class fields to perform their function,
   so observing the new value in aspectized software may be important to assess the coupling
   of an aspect with other classes/aspects <a href="#ceccato">[1]</a>.
</p>

<p><b>Implementation notes:</b></p>
<ul>
 <li>field access from introduced methods are counted as a access from aspect,</li>
 <li>(TODO) access to introduced fields are counted as an access to aspect's fields.</li>
</ul>



<h3><a name="cfa">Coupling between Modules (CBM)</a></h3>

<p>CBM is a number of modules or interfaces declaring methods or fields that are possibly
 called or accessed by a given module. It's an equivalent of the CBO metric from CK metrics suite.
 This is a combination of CFA and CMC metrics.
</p>

<p><b>View points:</b> <a href="#ck">[2]</a></p>
<ul>
 <li>Excessive coupling between object classes is detrimental to modular design and prevents
  class is, the easier it is to reuse it in another application.</li>
 <li>In order to improve modularity and promote encapsulation, inter-object class couples
  larger the number of couples, the higher the sensitivity to changes in other parts of
  more difficult.</li>
 <li>A measure of coupling is useful to determine how complex the testing of various
   higher the inter-object class coupling, the more rigorous the testing needs to be.</li>
</ul>

<p><b>Implementation notes:</b></p>
<ul>
  <li>see notes for CFA and CMC.</li>
</ul>



<h3><a name="rfm">Respone For a Module (RFM)</a></h3>

<p>RFM is number of methods and advices potentially executed in response to 
 a message received by a given module <a href="#ceccato">[1]</a>.</p>

<p>Similarly to the related OO metric, RFM measures the potential communication
 between the given module and the other ones. The main adaptation necessary to apply
 it to AOP software is associated with the implicit responses that are triggered
 whenever a pointcut intercepts an operation of the given module
 <a href="#ceccato">[1]</a>.
</p>

<p><b>View points:</b> <a href="#ck">[2]</a></p>
<ul>
 <li>If a large number of methods can be invoked in response to a message, the testing
  and debugging of the class becomes more complicated since it requires a greater level
   of understanding required on the part of the tester.</li>
 <li>The larger the number of methods that can be invoked from a class, the greater
   the complexity of the class.</li>
 <li>A worst case value for possible responses will assist in appropriate allocation of testing time.</li> 
</ul>

<p><b>Implementation notes:</b></p>
<ul>
 <li>RFM for a module is a sum of: number of methods in the module,
    number of methods invoked from methods, number of advices implicitly invoked,</li>
 <li>method introductions are counted as a member of an aspect,</li>
 <li>calls from method introductions are counted as a call from an aspect,</li>
 <li>constructors, constructor's invocations, methods invoked from constructors,
    advises on constructors are not counted,</li>
 <li>methods invoked in static initialisation and initialisation blocks
   are not counted.</li>
</ul>



<h3><a name="lco">Lack of Cohesion in Operations (LCO)</a></h3>

<p>LCO is number of pairs of operations working on different class fields
 minus pairs of operations working on common fields (zero if negative) <a href="#ceccato">[1]</a>.
 When all methods don't access to any field, then LCO = 0 <a href="#ck">[2]</a>.
</p>	

<p>Similarly to the LCOM (Lack of Cohesion in Methods) OO metric, LCO is
 associated with the pairwise dissimilarity between different operations belonging to
 the same module. Operations working on separate subsets of the module fields are considered
 dissimilar and contribute to the increase of the metric's value. LCO will be low if all operations
 in a class or an aspect share a common data structure being manipulated or accessed
 <a href="#ceccato">[1]</a>.
</p>
 
<p><b>View points:</b> <a href="#ck">[2]</a></p>
<ul>
 <li>Cohesiveness of methods within a class is desirable, since it promotes encapsulation.</li>
 <li>Lack of cohesion implies classes should probably be split into two or more sub-classes.</li>
 <li>Any measure of disparateness of methods helps identify flaws in the design of classes.</li>
 <li>Low cohesion increases complexity, thereby increasing the likelihood of errors during
  the development process.</li>
</ul>

<p><b>Implementation notes:</b></p>
<ul>
  <li>only access to instance variables are counted, static fields are omitted,</li>
  <li>field access from constructors are not considered,</li>
  <li>introduced methods and fields are treated as normal aspect's members.</li>
</ul>
</div>


<div class="h2"><h2><a name="pkg">Package dependecies</a></h2>

<p>The <a>aopmetrics</a> project provides two versions of package dependencies metrics suite.
 Both are based on Robert Martin's suite proposed in <a href="#martin">[3]</a>.
 First one is unmodified version of the suite. Second one contains modification
 of <b>Ce</b> metric (and is similar to <a href="http://www.refactorit.com/?id=29676"
 >RefactorIT version</a>). All definition excluding <b>Ce</b> metrics are identical
 for both versions.</p>


<h3><a name="not">Number of Types (NOT)</a></h3>

<p>NOT is a number of types within given package. This is an indicator of the extensibility
 of the package</p>

<p><b>Implementation notes:</b></p>
<ul>
  <li>Every class (normal, inner, anonymous), interface and aspect is counted as a type.</li>
</ul>


<h3><a name="a">Abstractness (A)</a></h3>

<p>A is the ratio of the number of abstract modules to the total number of modules
 in the package. Abstractness metric results are within a range of &lt; 0 ; &gt;. A value of zero
 indicates a completely concrete package and a value of one - a completely abstract.</p>

<p><b>Implementation notes:</b></p>
<ul>
  <li>Every interface, abstract class and abstract aspect is being considered.</li>
</ul>

<h3><a name="ca">Afferent Couplings (Ca)</a></h3>

<p>Ca is the number of modules outside the package, that depend upon modules within
  the package <a href="#martin">[3]</a>. This is an indicator of the package's
  responsibility.</p>

<p><b>Implementation notes:</b></p>
<ul>
  <li>Every (normal and qualified) type reference, supertype and implemented interfaces
     and type of every name reference are analysed.</li>
</ul>


<h3><a name="ce">Efferent Couplings (Ce)</a></h3>

<p>Ce is the number of modules inside the package, that depend upon modules outside
  the package <a href="#martin">[3]</a>. This is an indicator of the package's
  independence.</p>

<p><b>Implementation notes:</b></p>
<ul>
  <li>See notes for Ca.</li>
</ul>


<h3><a name="mce">Modified Efferent Couplings (Ce)</a></h3>

<p>The <b>aopmetrics</b> project provides also modified version of Ce metric.
  Original version doesn't indicate how big efferent couplings are.
  Package depending on single class has the same value of Ce metric like
  package with two dozens of dependencies.</p>

<p>Ce is the number of modules outside the package, that the modules
  in the package depend on. </p>

<p><b>Implementation notes:</b></p>
<ul>
  <li>See notes for Ca.</li>
</ul>


<h3><a name="i">Instability (I)</a></h3>

<p>I is the ratio of efferent coupling (Ce) to total coupling (Ce + Ca).
 such that I = Ce / (Ce + Ca). This metric is an indicator of the package's
 resilience to change. Instability metric results are within a range of &lt; 0 ; 1 &gt;.
 A value of zero indicates a completely stable package and a value of one indicates
 a completely instable package.</p>

<p>NOTE: Since the <b>aopmetrics</b> project provides two version of Ce metric, 
  therefore there're two versions of I metric.</p>

<h3><a name="dn">Normalized Distance from Main Sequence (Dn)</a></h3>

<p>Dn is the normalized perpendicular distance of the package from the idealized
line A + I = 1. This metric is an indicator of the package's balance between
abstractness and stability. Dn metric's results are within a range of &lt; 0 ; 1 &gt;.
A value of zero indicates perfect package design.</p>

<p>A package that sits on the main sequence (the line A + 1 = 1) is not <i>too abstract</i>
 for its stability, nor is <i>too instable</i> for its abstractness. It has the 
 <i>right</i> number of concrete and abstract classes in proportion to its efferent
 and afferent dependencies. Clearly, the most desirable positions for a package to hold
 are at one of the two endpoints of the main sequence. However, in my experience only about
 half the packages in a project can have such ideal characteristics. Those
 other packages have the best characteristics if they are on or close to the main sequence
 <a href="#martin">[3]</a>.
</p>

<p>NOTE: Since the <b>aopmetrics</b> project provides two version of Ce metric, 
  therefore there're two versions of Dn metric.</p>
</div>


<div class="h2"><h2><a name="refs">References</a></h2>

<ol>
  <li><a name="ceccato">Mariano Ceccato and Paolo Tonella, <i>Measuring the Effects of Software Aspectization</i></a>
    <a href="http://homepages.cwi.nl/~tourwe/ware/ceccato.pdf">PDF</a>
  </li>
  <li><a name="ck"> Chidamber and Kemerer, <i>A Metrics Suite for Object Oriented Design</i></a>
    <a href="http://www.pitt.edu/~ckemerer/CK%20research%20papers/MetricForOOD_ChidamberKemerer94.pdf">PDF</a>
  </li>
  <li><a name="martin">Robert Martin, <i>OO Design Quality Metrics, An Analysis of Dependencies</i> </a>
    <a href="http://www.objectmentor.com/resources/articles/oodmetrc.pdf">PDF</a>
  </li>
  <li><a name="jdepend"><i>JDepend documentation</i> </a>
    <a href="http://www.clarkware.com/software/JDepend.html">HTML</a>
  </li>
  <li><a name="refactorit"><i>RefactorIT documentation</i> </a>
    <a href="http://www.refactorit.com/?id=1376">HTML</a>
  </li>
</ol>
</div>

</body>
</html>
